---
title: 网络是如何连接的？
meta:
  - name: description
    content: 从最基础的网线连接开始，逐步介绍集线器、交换机、路由器等网络设备的工作原理，以及IP地址、NAT等核心网络概念，帮助读者理解网络连接的本质。
  - name: keywords
    content: 网络连接, 网线, 集线器, 交换机, 路由器, IP地址, NAT, 网络拓扑, 网络设备, 网络通信
---


# 网络是如何连接的？



## 0、自底向上构建网络

在这篇文章中，将会从“自底向上”的角度去看网络是如何连接的，也就是按照网络发展的顺序来构建的过程。

同时，在下一篇中我们还将从“自顶向下”的视角了解网页在网络中的传输过程，这一视角更贴近我们日常使用网络的顺序。



无论是哪个视角，都难免在构建/推理过程中会带入“上帝视角”，但是没关系，毕竟小北的目的是帮助大家把整个网络的知识串起来。



而不是去从头讨论网络的迭代发展历程，那是教科书和标准文档干的事情。



## 一、连接基础: 一根网线

回到 2000 年初，那是 PC 游戏的黄金时代，那个年代的同学都有过这样的经历：

宿舍里几个室友，每人一台电脑，想要一起玩《红色警戒》、《魔兽争霸》或者《星际争霸》。



如果你想和室友小王想要来一场红警对战，那么可以直接用一根网线把你们的电脑连起来:



![网络是怎么连接的](https://cdn.how2cs.cn/2024-12-04-computer-network-connection.svg)

这就是最简单的网络，仅仅由两个节点构成。


> 补充一下连线方式:
>
> 标准的网线（也叫双绞线）有八根不同的颜色线，分为 4 对，当两台电脑直接相连时，需要使用"交叉线"，就像两个人对话，一个人的嘴对应另一个人的耳朵




好了，你们终于可以在游戏里选择 IPX 或 TCP/IP 联机模式开始对战！

这个时候，室友小李也想要加入一起玩，怎么办呢，可以继续用网线把你们之间两两相互连接：

![网络是怎么连接的-三人相连](https://cdn.how2cs.cn/2024-12-04-computer-network-connection-3-.svg)

那如果还有其它室友也想继续加入，怎么办呢？

还是用更多的网线两两相连吗？

![四台电脑相连](https://cdn.how2cs.cn/2024-12-04-computer-network-connection-4-.svg)



当 N 台电脑需要互联时，两两相连的方式变得不可行，每增加一台设备，都需要与现有的每台设备建立连接，网线数量呈指数级增长。不仅硬件成本高昂，布线也会变得杂乱无章。



## 二、无脑转发：集线器

如果能把所有的网线都"揉"在一起，让每台电脑只需要用一根网线接入这个"公共连接点"，不就解决了网线数量暴增的问题了吗？

就像这样:

![多台电脑连在一起](https://cdn.how2cs.cn/2024-12-05-hub-network-connection.svg)





这个看似简单的想法，就催生了**集线器**（Hub）的诞生:

![集线器连接](https://cdn.how2cs.cn/2024-12-05-hub-network-connection-hub.svg)



有了集线器，N 台电脑只需要 N 根网线，每台设备只占用一个网口。



但是集线器是如何实现把它们所有连接起来的呢？



原因在于，集线器就像一个"复读机" - **当收到任何一台电脑发来的数据时，它会无差别地把这些数据转发给所有连接的设备**。



比如电脑 A 发送数据给电脑 B，集线器会把这份数据同时发给电脑B、C、D...，就像在一个房间里大家同时说话一样。





**那么 C 和 D 怎么知道这个数据不是发送给自己，而是发给 B 的呢？**



这就要说到网络通信中的 **MAC 地址**了，每个网卡都有一个全球唯一的 MAC 地址，就像每个人的身份证号一样，出厂就写到了设备里。

当电脑 A 发送数据时，会在数据包中标记：

- 发送方 MAC地址: 电脑 A 的地址
- 接收方 MAC 地址: 电脑 B 的地址

![MAC 数据包](https://cdn.how2cs.cn/2024-12-04-mac-packet-%E6%95%B0%E6%8D%AE%E5%8C%85.svg)

虽然集线器把数据发给了所有人，但其他电脑（C、D）收到数据包后会检查接收方 MAC 地址。

发现不是给自己的，就会自动丢弃这个数据包（如果遇到不讲规矩的，也可以不丢弃，这就是局域网窃听）。

这就像在一个房间里，虽然每个人都能听到别人的对话，但知道不是在叫自己就会自动忽略。

集线器是共享型设备，在同一时刻只能有一个节点发送数据，其他节点只能处于监听状态，所以它一般只能支持单工通信，这种同时传输数据时可能会产生冲突的节点的集合我们也叫做**冲突域**。

处于同一个冲突域的节点只能一个一个发送数据。

总结下集线器特点:

![集线器特点](https://cdn.how2cs.cn/2024-12-04-hub-features.svg)



但这种方式存在明显的安全隐患和效率问题：

1. 带宽浪费 - 不相关的电脑也会收到数据
2. 性能下降 - 所有设备共享带宽，越多设备连接，网络越拥挤
3. 安全隐患 - 所有数据对所有设备可见



#### MAC 地址

简单再介绍一下 MAC 地址:

MAC地址（Media Access Control Address）是网卡的物理地址，48位二进制数，通常用12个十六进制数表示。

* 前24位：组织唯一标识符(OUI)，由IEEE分配给厂商
* 后24位：由厂商自行分配给网卡

全球唯一性：

- IEEE统一管理 OUI 分配
- 制造商负责确保后 24 位不重复
- 每个网卡出厂时烧录到 ROM 中

(PS: 虽然是硬件地址，但可通过软件临时修改，Windows/Linux都支持MAC地址修改，部分网络安全工具可随机生成MAC地址



比如我命令行 ifconfig 查看本机的 MAC 地址为: `80:a9:97:39:ae:27`

后面的图解中，为了简单，我会把 MAC 地址只保留 4 个十六进制数，比如 AA-11。




## 三、交换机：定向转发


那你可能会想，如果有个聪明一点的集线器，**能够按照目标 MAC 地址定向的转发数据包就好了！**



恭喜你，发明了**交换机**（Switch）！



交换机通过学习各个端口连接设备的 MAC 地址，构建一个 **MAC 地址表**，实现了数据的"精准转发"。

当数据包到达时，交换机会查找 MAC 地址表：

- 如果找到目标MAC对应的端口，就只从那个端口转发
- 如果找不到，才会向所有端口广播（这种情况叫网络泛洪）

这种工作方式不仅提高了网络效率，还增强了通信安全性。



每个设备只能收到发给自己的数据包，也就不用担心被别人"偷听"了。



我们知道交换机最重要的就是它那个小本本- **MAC 地址表**，那么这个地址表是谁去生成的呢？怎么生成的呢？



答案是，**动态学习**，这其实在网络设备中非常常见，动态学习有利于网络设备随时接入或者退出，自适应。



让我们以一个具体的例子来说明交换机是如何工作的：

* **初始状态： 当交换机刚启动时，它的 MAC 地址表是空的，不知道任何设备的位置。**

![交换机初始](https://cdn.how2cs.cn/2024-12-05-switch-network.svg)


* **学习过程**： 假设电脑 A（MAC: AA-11）通过端口 1 发送数据给电脑 B，虽然这时交换机不知道 B 在哪个端口，但它学到了一条重要信息："啊，MAC地址为 AA-11 的设备在端口 1 上"，交换机会立即记录这条映射关系：

![MAC 地址表-step1](https://cdn.how2cs.cn/2024-12-04-mac-address-table-step1.svg)



* **泛洪： 因为不知道电脑 B 的位置，这时交换机会向除了端口 1 以外的所有端口转发这个数据包。这种行为叫做"泛洪"（Flooding）。**



* **持续学习： 当电脑 B（MAC: BB-BB-BB）回复数据时，交换机又学到了新信息："原来 BB-BB-BB 在端口 2"。** MAC 地址表更新为：

![MAC 地址表-step2](https://cdn.how2cs.cn/2024-12-04-mac-address-table-step2.svg)

* **精准转发： 下次当电脑 A 再发送数据给电脑 B 时，交换机查表就知道："B 在端口 2"，于是只向端口 2 转发数据包。其他端口的设备不会收到这些数据，完美！**

相比集线器的"无脑广播"，交换机实现了"精准投递"。

这种精准转发带来了几个重要的好处：

* 节省了带宽
* 提升安全性（不会把数据包泛洪到其它人那里）



当然了，这个 MAC 地址表中的映射关系也会老化（通常是 5 分钟）。如果在这段时间内没有收到某个 MAC 地址的数据包，对应表项就会被删除，这种工作机制使得交换机能够自动适应网络变化，高效地转发数据。



因为交换机能够识别 MAC 地址，根据 MAC 地址做路由，所以我们也叫它 **二层交换机**，因为对应的 TCP/IP 模型中数据链路层。



好了，到这里寝室里的小帅们终于可以连成一个局域网打游戏了。



但，隔壁寝室小北这时候说他们寝室也要一起玩，但是这个交换机网口只有 5 个，怎么办呢？



小北说我们用两个交换机，把交换机连起来不就行了？这个可行吗？



完全可以！两个交换机完全可以连接在一起形成一个更大的网络，如图所示（为了简化图示，每个交换机连接的电脑 只花了 2 个）：



![](https://cdn.how2cs.cn/2024-12-08-two-switches-network.svg)

这种情况下，交换机是如何做到数据传输的呢？

最开始两个交换机的 MAC 地址表都是空的，当电脑 A (MAC: AA-11)要和电脑 B (MAC: BB-22)通信时，整个过程如下:

1. 电脑 A 发出数据包，第一个交换机不认识目标 MAC 地址 BB-22，就向所有端口转发，包括连接第二个交换机的端口
2. 第二个交换机收到后，也不认识地址 BB-22，继续广播到其它端口
3. 此时电脑 B 收到数据后，处理后，再往回 AA-11 发送数据包响应
4. 这时两个交换机都学到了:
   - **Switch 1 知道了AA-11在端口1，CC-33 在连接 Switch 2 的端口**
   - **Switch 2 知道了 BB-22 在端口3，AA-11在连接 Switch 1的端口**



这样逐步学习后，两个寝室的同学就能愉快地一起玩游戏了，但是每一个广播包(比如ARP请求)会在整个网络传播，这样能能接收广播数据包的所有设备的集合叫做一个**广播域**（可以把广播域理解为一个广场，在广场上的人，大声喊话的时候其它人都能听到）。



## 四、路由器 & IP 地址



我们继续小帅他们的故事，随着游戏越打越好，他们想举办一个校园联机游戏大赛，让不同宿舍楼的同学都能参与。

但问题来了，如何组织这么大规模的设备接入一个网络呢？还是继续用 N 个交换机互相连接吗？

让我们想象一下校园网络的规模：

- 一栋宿舍楼有 500个房间，每个房间平均四个同学-四台电脑，学校有10 栋宿舍楼

这意味着大约 2w 个MAC地址，每个交换机都需要记住这些地址，这带来两个致命问题：

* MAC地址表爆炸，表项太多，查找、更新都受影响
* 这些设备处于一个**广播域**，广播包会导致整个网络瘫痪（想象一下广场上 2w 个人同时在大声喊话的场景）



所以很自然的想法：

把网络分成多个小组（就像城市分区一样），每个小组内部可以广播，但小组之间要有个"管理员"负责转发消息。



关键是如何设计一个地址系统，让设备既知道自己属于哪个小区，管理员又能据此找到目标小组？



如果继续用交换机连接这些时，问题依然存在 - MAC地址就像身份证号，虽然能唯一标识一个设备，但无法告诉我们这个设备在哪个组。



根本原因在于 MAC 地址是出厂就分配好的，它不会有任何的层级关系，MAC地址是平面的，48位随机数。



就像现实生活 - 身份证号虽然能唯一标识一个人，但不能帮你找到这个人（你可能今天在深圳，明天就去北京了）。



而"深圳市南山区xx街xx号"这样的地址，却能让你一步步定位：先找到深圳，再找到南山区，最后找到具体位置。



我们需要的正是这样一个分层的地址系统。



**而这，正是IP地址的设计思路！** IP 地址也具备这样的定位能力:

![](https://cdn.how2cs.cn/2024-12-05-IP%20%E5%9C%B0%E5%9D%80.png)

而那个根据 IP 地址在小组之间转发消息的管理员就是**路由器**。



IP地址构成：

- IP地址（如192.168.1.11）是32位二进制数，分 4 段显示
- 每段0-255，称为"点分十进制"



在同一个小组，我们一般叫做一个**子网：**

* 同子网内的设备可以直接通信

* 不同子网要通过路由器转发



那么怎么判断是不是在一个子网呢？这就需要提到子网掩码了：

子网掩码也是由 32 位二进制数组成，连续的 1 表示网络部分，连续的 0 表示主机部分。

如 255.255.255.0 转为二进制就是 24个1和 8 个 0，简写为 /24，表示前面 24 位都是网络部分。

判断同网段：

- 将IP地址和子网掩码做"与"运算，结果相同的IP就在同一网段
- 如：192.168.1.11和192.168.1.22都与255.255.255.0运算后得到192.168.1.0



网关：

- 通常是路由器的IP地址，作为子网对外的"门户"
- 不同子网通信时，数据先发给网关
- 比如192.168.1.1常作为默认网关





最初的宿舍网络里，设备只需要 MAC 地址就能通信，就像在一个小区里互相喊名字就行。

但随着网络变大，这种方式不再可行，所以我们引入了 IP 地址来解决这个问题。

但数据包最终还是要通过网线传输，这就需要 MAC 地址。就像寄快递：

- IP 地址相当于城市、街道：决定包裹该送到哪个区域
- MAC 地址相当于收件人身份信息：最后一步实际交付



### 局域网内设备通信

我们先来看看引入 IP 地址后，是如何在一个局域网内通信的:



![路由器构成的局域网](https://cdn.how2cs.cn/2024-12-08-router-network.svg)



(图中为了简化，**我们就把交换机去掉了，实际上在局域网内，现代路由器也具备交换机的能力，也能学习 MAC 地址和 端口的映射关系**，实际家庭生活中，我们也很少会用到交换机)



假设小北（电脑A）想给小神仙（电脑B）发送一条游戏邀请。



小北的电脑知道小神仙的 IP 地址是192.168.1.22，那它会怎么做呢？



首先，我们说了，同一个子网的设备之间可以直接通信，直接通信的意思就是你拿到想发消息给对方的设备的 MAC 地址，然后封装一个 MAC 数据包即可，**MAC 数据包的数据部分其实是一个 IP 数据包**（下一层的数据部分包含完整的上一层包的 header 和数据）：


![](https://cdn.how2cs.cn/2024-12-05-ip-in-mac-packet.svg)


如果不是一个子网，那么只需要拿到网关的  MAC 地址，然后目的 MAC 地址发送给网关路由器，路由器会根据你的目的 IP 帮你转发到其它网络中。

所以整个处理过程如下：

电脑 A 要判断电脑 B 是不是和自己在同一个网络里，它看到自己的IP是192.168.1.11，子网掩码是255.255.255.0，**计算后发现："嗯，都是192.168.1开头，我们在同一个子网内，可以直接通信。"**

但是要发送数据，光知道 IP 地址是不够的，在同一个子网内，计算机之间要用 MAC 地址通信。

所以电脑 A 想：“我得先知道电脑 B 的 MAC 地址”。于是它在局域网内大喊一声（发送ARP广播）：**''谁是192.168.1.22啊？请告诉我你的MAC地址！''**

同一个子网的所有电脑都收到了这个广播，但发现叫的不是自己，都默默丢弃了，只有小神仙的电脑 B 回应道：**"192.168.1.22 是我！我的MAC地址是BB-22。"**

电脑 A 收到这个回应后，会把 192.168.1.22-BB-22 这个映射关系记在自己本机缓存中，这个就叫 ARP 缓存。

这个过程就是 ARP 协议的作用 - **通过IP地址找到对应的MAC地址**。

有了 MAC 地址后，小北的电脑就可以直接发送数据包了，它把游戏邀请包装成一个特殊的"双层信封"：先在内层信封上写上IP地址"192.168.1.22"（这就是IP头），然后把它放入外层信封，在外层信封上写上"收件人MAC地址：BB-22"（这就是MAC头）。

这样的双层结构保证了数据包既能通过 IP 地址确定目的地，又能通过 MAC 地址在本地网络中准确投递。

路由器(携带交换机功能)看到 MAC 地址，立刻就知道该从哪个端口转发出去，于是数据包就准确送达了小神仙的电脑。


### 不同子网设备通信

我们刚才举的是同一个子网设备之间通信，现在我们来看看在不同子网之间的设备如何通信。

还是那个例子:

**假设小北的电脑A（192.168.1.11）要给小神仙的电脑B（192.168.2.22）发送一个游戏邀请**

(PS: 注意此时，他们在不同的子网内，一个是 192.168.1.0/24 一个是 192.168.2.0/24)



1. 首先，电脑 A 要判断目标IP（192.168.2.22）是否在同一子网，它看了下自己的网络信息：

   - 自己的IP是192.168.1.11、对方的 IP 是 192.168.2.22

   - 子网掩码都是255.255.255.0 计算后发现："对方网段是192.168.2.0，而我是192.168.1.0，显然不在同一个子网，需要通过网关转发。"

2. 电脑 A 查看自己的网络设置，发现默认网关 IP 地址是192.168.1.1，但是不知道 MAC 地址，于是：

   - 发出 ARP 广播："谁是192.168.1.1？请告诉我你的MAC地址！"
   - 路由器 1 收到后回应："192.168.1.1 是我，我的 MAC 地址是 SS-11"

3. 电脑A 收到路由器 1 的回应后，开始准备发送数据包：

   - IP头：目的地址填写最终目标B的IP（192.168.2.22）

   - MAC头：目的地址填写网关的MAC地址（SS-11）

4. 路由器1收到数据包后：

   * 查看路由表："192.168.2.0/24这个网段...通过我的接口连接着路由器2"

   * 把旧的 MAC 头换掉，换上一个新的 MAC 头（源 MAC 地址是路由器 1 的 MAC 地址：SS-11，目的地址是路由器 2 的MAC 地址： SS-22 ），然后从连接路由器2的接口转发出去

   * 路由器 1 之所以知道怎么转发数据包，因为它维护一个路由表，至于这个路由表如何创建和维护的，后文会简单说明

   路由表示意图：

   

   ![路由表示意图](https://cdn.how2cs.cn/2024-12-09-router1-table-watermark-4.svg)

5. 路由器2收到数据包后：

   - 发现目的IP（192.168.2.22）在自己所在的子网内
   - 发出 ARP 广播询问电脑 B 的 MAC 地址
   - 得到电脑 B 的回应后，再次将数据包 MAC 地址替换掉（源变为路由器 2，目的变为电脑 B）
   - 将数据包转发给电脑B




![两个路由器构成的网络](https://cdn.how2cs.cn/2024-12-08-two-subnet-router-network.svg)

这就像一封跨城市的信件：

- 你先把信交给本地邮局（路由器1）
- 本地邮局通过邮政系统（路由器间的连接）将信转给目的地的邮局（路由器2）
- 最终目的地的邮局再把信送到收件人手中（电脑B）

在整个过程中，IP头（目的地址）始终保持不变，而 MAC 头（相当于邮递过程中的中转单）每经过一个路由器都会被替换一次。



**（PS：以上过程不体现 NAT，如果你不知道 NAT 那就忽略这个 PS）**



> 那么在步骤 4 中，路由器 1 是怎么知道 192.168.2.0/24 这个网段的包都发给路由器 2 的呢？

答案是 路由器 1 维护了一张**路由表**

路由表的生成和维护有很多路由协议，这里简单说明下路由表的几种形成方式：

1. 直连网段自动发现：
   - 路由器1知道自己的端口1连接着192.168.1.0/24网段，这是自动学习的 （同一个路由器下所有 LAN 口都是在一个子网（划分 VLAN 除外））
   - 路由器2知道自己的端口1连接着192.168.2.0/24网段，这也是自动学习的
2. 人工配置（静态路由）：
   - 网络管理员手动配置告诉路由器1："要去192.168.2.0/24网段，需要从连接路由器2的接口发送"
   - 同样配置路由器2："要去192.168.1.0/24网段，需要从连接路由器1的接口发送"
3. 动态路由协议：
   - 路由器们会定期互相交流："我这边连接着哪些网段，你那边连接着哪些网段"
   - 比如最早期的 RIP 协议，路由器们每 30 秒就会广播自己知道的路由信息
   - 现代网络更常用 OSPF、BGP 等更先进的协议，它们会计算出最佳的转发路径

这就像两个邮局之间需要知道对方负责哪些区域的投递一样：

- 要么上级邮政部门明确规定（静态路由）
- 要么邮局之间定期开会交流各自负责的区域（动态路由）
- 每个邮局自然知道自己直接投递的范围（直连网段）

在我们这个简单的两路由器网络中，用静态路由配置就足够了，但在大型网络中，通常会使用动态路由协议，让路由器们自动学习和更新网络拓扑信息。



这个网络还可以继续扩大，形成整个校园网 -> 城域网-> 国家网络 -> 全球互联的网络：

![互联的网络](https://cdn.how2cs.cn/2024-12-09-2024-12-09-2223.png)

但是最基本的MAC层、IP层的数据包转发最基本的原理就是这样，在这个过程中有几个重要的表和地址，简单总结如下：

1. MAC 地址表：
   - 存在于交换机中（现代路由器基本替代了交换机这部分功能），记录着MAC地址与交换机端口的对应关系
   - 帮助交换机在同一广播域内准确转发数据包
2. ARP 表：
   - 缓存在每台网络设备中，记录 IP 地址和 MAC 地址的对应关系
   - 避免重复发送 ARP 广播请求
3. 路由表：
   - 存在于路由器中
   - 记录网段与出接口的对应关系，指导路由器如何转发跨网段的数据包
4. 重要概念：
   - MAC地址：设备唯一标志，也是用于同一广播域内设备的物理标识
   - IP地址：用于全局范围内设备的逻辑标识（IP 地址是一个逻辑地址）
   - 子网掩码：用于划分网段，判断目标 IP 是否在同一子网
   - 网关地址：当前网络到其他网络的"桥梁"

无论网络规模如何扩大，都是在这些基本原理上不断扩展：**更复杂的路由协议、更多层的网络设备、更智能的转发策略**，但底层的数据包转发逻辑始终遵循这些基本规则。





## 五、传输层协议：UDP & TCP

上面我们使用路由器、交换机、IP 地址、MAC 地址等设备就能构成基本的网络，可以实现主机到主机的数据传输，双方就像一根网线直连一样，完全不需要关注中间的网络节点，但是"这就够了吗？"

**并不是。**

IP 协议只负责把数据包从一台主机传输到另外一台主机，**但是一台电脑上可能运行着多个应用程序（比如游戏、浏览器、聊天软件等），当数据包到达电脑后，应该交给哪个应用程序呢？**

一个电脑上运行的部分应用程序如下图：

![端口多路复用](https://cdn.how2cs.cn/2024-12-09-host-applications-simple.svg)

我们可以引入端口的概念， 用 **端口号**用来区分不同的应用程序，端口号是一个 0-65535 的整数，比如:

- 80 端口通常用于网页服务
- 21 端口用于FTP服务
- 25 端口用于邮件服务



每个应用程序监听来自不同端口的数据:

![](https://cdn.how2cs.cn/2024-12-09-host-applications-with-ports-arrow.svg)

这就像一个大楼的门牌号（IP地址）和房间号（端口号）。

### UDP：简单但不可靠

有了端口，最简单的传输方式就是：**把数据包发给对方主机的指定端口，这就是 UDP 协议的基本工作方式。**

除了多了端口号来区分不同应用，它几乎不提供超出 IP 层数据传输能力的服务。

简化的完整 UDP 数据包如下图，在原来的 IP 层数据包的基础上加上源端口和目标端口：

![UDP 数据包图](https://cdn.how2cs.cn/2024-12-09-udp-packet-balanced.svg)



UDP 的特点是：

- 不建立连接，想发就发
- 不保证可靠送达，发出去就不管了
- 不保证按序到达，后发的包可能先到
- 速度快，开销小

就像寄一封普通信件，你把信件投进邮筒就完事了，不用等对方签收，也不知道信件是否成功送达。

### TCP：可靠连接

但是有些场合（比如文件传输、网页浏览）我们需要保证数据的可靠性，并且一个字节都不能丢，这时就要用到 TCP 协议。

TCP 会在通信前先建立连接（三次握手），确保双方都准备好了再传输数据。就像打电话前要先确认"喂，能听到吗？"

TCP的特点：

- 建立可靠连接
- 有序列号机制，保证数据按顺序到达
- 有丢包重传机制
- 有流量控制和拥塞控制功能
- 开销较大，速度较慢（只是相较 UDP）

TCP 报文示意图如下，和 UDP 类似，最关键的也是端口号信息，除此以外 TCP 还有很多序列号、确认号这样的控制信息没有在图中画出来:

![TCP 报文](https://cdn.how2cs.cn/2024-12-09-tcp-packet.svg)



在这也给大家看一下完整的 TCP 头部字段构成，看着就知道 TCP 协议巨复杂！

![TCP 头部字段](https://cdn.how2cs.cn/2024-11-16-tcp-header-with-options-adjusted.svg)



TCP 在发送数据前会通过三次握手，确认双方都已经准备好发送和接收数据，三次握手示意图如下：

![TCP 三次握手](https://cdn.how2cs.cn/2024-12-09-tcp-handshake-simple.svg)



建立连接之后，双方就可以在这条连接之上互相发送数据了。TCP 协议会像一个尽职的快递员一样，保证数据包按顺序可靠地传输到对方，如果中途丢失还会主动重发，直到确认对方收到为止。

在完成所有数据传输后，双方需要协商关闭连接，这个过程叫做四次挥手。

之所以需要四次挥手，是因为 TCP 的全双工特性，每个方向都需要单独关闭。

这就像两个人结束通话时说："我说完了。" 、"好的，我知道了。"、 "我也说完了。"、"好，那挂了啊。"

TCP 四次挥手示意图如下:

![](https://cdn.how2cs.cn/2024-12-09-tcp-wave.svg)



再回到我们打游戏的例子，红警游戏中的实时位置数据使用 UDP 传输，因为实时性比准确性更重要；而游戏存档、聊天消息则使用 TCP，因为这些数据必须准确完整。

就像快递服务，UDP像是快递员骑电动车送快递，追求速度但可能出错；TCP则像押运车运送贵重物品，反复确认保证安全。这两种传输层协议为应用程序提供了不同的服务选择。

TCP VS UDP 应用场景举例:

![TCP和 UDP 应用场景](https://cdn.how2cs.cn/2024-12-09-protocol-applications.svg)


## 六、NAT：公网IP不够用了

至此，应用程序已经可以通过 Socket 编程使用 TCP/UDP 来传输自己的数据，整个互联网世界也是基于此构建的。

但是还有一个问题，是我们日常上网非常常见的，所以最后拿出来讲一下。



前面我们讲了如何用 IP 地址在不同网段之间通信，但是还有一个问题：**全球IPv4地址已经不够用了。**



因为在最初版本的互联网协议（IP 版本 4 或简称 IPv4）中，这些地址长度为 32 位，这意味着总共有 2^32 个（约 40 亿）可能的地址。地球上有超过 40 亿人，其中许多人拥有不止一台设备，因此实际上不可能每台设备都有唯一的地址。



那么怎么让所有人都能正常上网呢？ 

所以一定需要**复用 IP 地址**，于是我们划分了三类 IP 地址作为私有 IP 地址（局域网地址）：

![私有 IP 地址范围](https://cdn.how2cs.cn/2024-12-09-local-network-ranges.svg)



这些范围内的 IP 地址，大家家里、公司、学校、云厂商等组织可以随便使用。

最常见的是 C 类地址段，比如家用路由器默认IP一般是192.168.1.1，正是因为大家可以随便使用，所以没有办法根据这些私有 IP 地址定位，他们只能在各自的局域网内保持唯一，无法在全球唯一，**所以这些地址只能在局域网内使用，不能在互联网上直接访问。**



那么当这些设备想要访问的外网的时候，怎么办呢？



一个很自然的想法是，一个子网的设备对外时共用一个或者多个公网 IP，那么如何实现呢？ 



端口号允许同一台计算机上的多个应用程序共享一个 IP 地址，那么基于这个扩展一下，也能使用端口号来支持多台计算机共享一个 公网 IP 地址。



而这就是 NAT（Network Address Translation）技术，NAT 允许多台设备共用一个公网IP，就像一个大院子只有一个门牌号，但里面却住着很多家庭。



我们来举个例子说明 NAT 的工作过程：



![NAT 工作示意图](https://cdn.how2cs.cn/2024-12-09-nat-topology-fixed-1.svg)

假设小北用电脑（内网IP：192.168.1.11）访问淘宝网（DNS 解析后 IP 为 203.0.113.1），这个过程中 NAT 是这样工作的：

1. 小北的电脑发送数据包到路由器：
   - 源IP: 192.168.1.11，源端口: 4567
   - 目标IP: 淘宝服务器 203.0.113.1，目标端口: 80
2. 路由器收到数据包后，对它进行 NAT 转换：
   - 把源IP改成路由器的公网IP（比如：101.202.33.44），路由器可以绑定多个 IP 地址，不同出口对应不同的 IP 地址。
   - 修改源端口为一个新端口（比如：6789），在 NAT 表中记录这个映射关系：192.168.1.11:4567 ←→ 101.202.33.44:6789
3. 淘宝服务器收到请求后回复数据包：
   - 发给路由器的公网IP（101.202.33.44:6789）
   - 路由器查 NAT 表，找到对应的私网IP和端口：192.168.1.11:4567
   - 把数据包转发给小北的电脑（192.168.1.11:4567）

NAT 技术极大地缓解了 IPv4 地址短缺的问题，就像一个大型小区的安保系统，NAT 既是门卫（控制进出），又是接待处（管理访客），让内部人员能够安全便捷地与外界交流。

虽然这个系统不是完美的，但在当前阶段，它仍是互联网得以正常运转的重要基石。


## 总结

我们从一根简单的网线开始，到最后构建起了整个互联网，这个过程像搭积木一样，一步步解决着不同的问题：

- 最开始，我们用**网线**连接两台电脑，让室友之间能一起玩游戏
- 后来用**集线器**和**交换机**解决了多人连接的问题，但仅限于小范围内
- 接着引入了**路由器**和 **IP 地址**，让不同区域的网络能够互联
- **TCP/UDP** 协议则确保了数据传输的可靠性和灵活性
- 最后，**NAT** 技术让有限的公网 IP 地址能够服务更多的设备

这些技术的发展，就像是一个个解决方案，形成了不同的网络层，也对应着网络发展过程中遇到的各种挑战，每一层都在解决特定的问题：

- **物理层**解决"如何传输电信号"
- **链路层**解决"如何在直连的设备间可靠通信"
- **网络层**解决"如何在复杂网络中找到目的地"
- **传输层**解决"如何保证数据完整性和应用程序间的通信"



从你敲下网址的那一刻起，DNS 解析、TCP 连接、IP 路由、网卡通信... 数据包就像一封特殊的信件，在这个精密的体系中穿梭，最终准确送达目的地。

这就是互联网的魅力 - 它用优雅的分层结构，让世界上的每一台设备都能相互连接。

**而这一切的基础，不过是我们最初架设的那根网线，和想要玩游戏的简单愿望。**

从宿舍联机打游戏，到今天的云计算、5G网络、物联网...互联网仍在飞速发展。

但不管技术如何演进，这些基础的网络原理都是基石。